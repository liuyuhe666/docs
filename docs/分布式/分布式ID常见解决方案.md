# 分布式 ID 常见解决方案

分布式系统里 **唯一 ID** 是非常核心的需求（订单号、用户号、消息 ID 等等）。常见解决方案主要有以下几类：

## 1. 数据库自增 ID

**方案**：使用数据库的自增主键（`AUTO_INCREMENT` 或 `SEQUENCE`）。

- 优点：实现简单，可靠性高。
- 缺点：单点瓶颈，扩展性差，性能有限。
- 改进：

  - **号段模式**：一次性从数据库申请一段 ID（如 1\~1000），应用侧在内存里递增，耗尽再申请新的号段。
  - **优点**：减少数据库压力，提高吞吐量。
  - **缺点**：依赖数据库，DB 挂了不可用，号段续租需要考虑。

## 2. UUID（通用唯一标识符）

**方案**：直接用 UUID（128 位，通常 36 位字符串）。

- 优点：无中心化依赖，生成快，简单。
- 缺点：

  - 太长（存储和传输成本高）。
  - 无序（影响数据库索引性能）。
  - 不可读，不适合用作业务单号。

改进：可以用 **UUID v1/v2（带时间戳 + 机器号）** 或 **UUID v7（按时间排序）**，后者能解决有序性问题。

## 3. Snowflake 算法（Twitter 开源）

**方案**：用一个 **64 位长整型** 编码，结构通常是：

```
0 | 时间戳 | 数据中心ID | 机器ID | 序列号
```

- 优点：高性能，本地生成，趋势有序，长度短（long 型）。
- 缺点：

  - 需要保证时间回拨问题（时钟回调可能导致重复）。
  - 依赖于机器号分配，需要统一管理。

- 代表实现：Snowflake、Leaf（美团）、百度 UidGenerator。

## 4. Redis / 缓存生成

**方案**：用 Redis 的 `INCR` 或 `INCRBY`。

- 优点：高性能，分布式天然支持，递增有序。
- 缺点：依赖 Redis，单点/集群问题，可能丢数据（持久化没跟上）。
- 改进：

  - Redis Cluster 水平扩展。
  - 预分配号段。

## 5. ZooKeeper / Etcd

**方案**：利用其顺序节点特性生成分布式自增 ID。

- 优点：强一致性保证，不会重复。
- 缺点：性能较差，适合低并发场景。

## 6. 时钟+随机数 / Redis+时间

**方案**：时间戳（毫秒级/秒级）+ 机器号 + 随机数。

- 优点：实现简单，基本不会冲突。
- 缺点：需要额外考虑并发冲突和排序（不完全有序）。
- 常见用法：订单号 `yyyyMMddHHmmss + 随机数`。

## 总结对比

| 方案          | 有序性   | 可读性 | 依赖性      | 性能 | 适用场景               |
| ------------- | -------- | ------ | ----------- | ---- | ---------------------- |
| DB 自增/号段  | 有序     | 较好   | 数据库      | 中等 | 中小型系统，依赖数据库 |
| UUID          | 无序     | 差     | 无          | 极高 | 分布式标识、追踪日志   |
| Snowflake     | 有序     | 一般   | 时钟/机器号 | 极高 | 高并发、需要有序 ID    |
| Redis INCR    | 有序     | 一般   | Redis       | 高   | 依赖缓存的分布式系统   |
| ZooKeeper     | 有序     | 一般   | ZK          | 低   | 低并发，强一致要求     |
| 时间戳+随机数 | 趋势有序 | 较好   | 时钟        | 高   | 订单号、业务编号       |
