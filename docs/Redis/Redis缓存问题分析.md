# Redis 缓存问题分析

## 🧊 缓存雪崩

### 现象

大量缓存**在同一时间失效**，导致所有请求都直接打到数据库，数据库压力瞬间暴增，可能被击垮。

### 举例

比如商品缓存的过期时间都设为 10 分钟，恰好 10 分钟后大量缓存同时过期 → 所有请求直击 DB。

### 解决方案

1. **随机过期时间**

   - 给缓存加一个随机值，避免同时过期：

     ```python
     expire = 600 + random.randint(0, 60)
     ```

2. **缓存预热**

   - 系统启动或流量高峰前，提前加载关键数据到缓存中。

3. **互斥锁 / 分布式锁**

   - 控制只有一个线程/节点去重建缓存，其余请求等待或返回旧数据。

4. **多级缓存**

   - 使用本地缓存（如 Caffeine、Guava）+ Redis，多层缓冲减少 DB 压力。

## 🧱 缓存穿透

### 现象

查询一个**缓存和数据库中都不存在**的 key，每次都会打到数据库，形成大量无效请求。

### 举例

请求一个不存在的用户 ID，例如 `/user?id=-1` 或 `/user?id=999999`，Redis 和 DB 都没有，DB 会被频繁访问。

### 解决方案

1. **缓存空值**

   - 查询结果为空时，也缓存一个短期的“空对象”：

     ```python
     redis.setex(key, 60, "NULL")
     ```

   - 之后相同请求直接命中 Redis。

2. **布隆过滤器（Bloom Filter）**

   - 在请求到 Redis 前，用布隆过滤器判断 key 是否存在，若确定不存在，直接拦截。
   - 常用于海量数据（如商品、用户 ID）。

3. **接口层防护**

   - 对请求参数做合法性校验，例如过滤掉负数、空值等。

## ⚡ 缓存击穿

### 现象

**某个热点 key** 恰好失效的那一刻，有大量并发请求同时访问它 → 多个请求都打到数据库，造成瞬间压力。

### 举例

热门商品详情缓存过期的瞬间，有成千上万请求并发访问，全部同时查数据库。

### 解决方案

1. **互斥锁（分布式锁）**

   - 当缓存失效时，只有一个线程去查询 DB 并更新缓存，其他线程等待或返回旧数据。
   - 常见实现：

     ```python
     if not redis.get(key):
         if acquire_lock(key):
             data = query_db()
             redis.setex(key, ttl, data)
             release_lock(key)
         else:
             time.sleep(0.05)
             retry()
     ```

2. **逻辑过期**

   - 不删除缓存，而是给缓存数据加一个逻辑过期时间字段：

     ```json
     { "data": {...}, "expire_time": 1696900000 }
     ```

   - 若逻辑过期但未真正清除，后台异步线程重建缓存，前端仍可读取旧数据。

3. **提前续期**

   - 热点 key 临近过期时，由后台任务自动续期（延长 TTL）。

## 🧭 总结

| 问题类型 | 触发条件                      | 表现                  | 主要应对策略                       |
| -------- | ----------------------------- | --------------------- | ---------------------------------- |
| 缓存雪崩 | 大量 key 同时过期             | 短时间数据库被打爆    | 过期时间随机化、缓存预热、多级缓存 |
| 缓存穿透 | 查询不存在的数据              | 每次都查数据库        | 缓存空值、布隆过滤器、参数校验     |
| 缓存击穿 | 热点 key 失效瞬间被高并发访问 | 单个 key 造成 DB 突刺 | 分布式锁、逻辑过期、提前续期       |
