# GC 调优方法

Java 的垃圾回收（GC）调优是 JVM 性能优化中的核心环节。调优的目标通常包括：**降低 GC 频率、缩短停顿时间、提高吞吐量**。

下面我将从原理、监控、策略和参数四个角度系统讲解。

## 理解 GC 基础机制

### 1. 堆结构

Java 堆主要分为：

- **新生代（Young Generation）**
  包含 Eden 区、Survivor From 区、Survivor To 区。对象在这里“出生”，GC 频繁。
- **老年代（Old Generation）**
  存放长生命周期或多次晋升的对象。
- **永久代 / 元空间（PermGen / Metaspace）**
  存放类元数据、常量池等（JDK 8 之后用 Metaspace 替代，存放在本地内存中）。

### 2. 垃圾回收类型

- **Minor GC**：只回收新生代，频繁但速度快。
- **Major GC / Full GC**：回收老年代（可能包含新生代），耗时较长。

## 常用垃圾收集器类型

| 收集器                    | 代          | 特点                   | 适用场景             |
| ------------------------- | ----------- | ---------------------- | -------------------- |
| **Serial**                | 新生代      | 单线程、简单稳定       | 单核、小内存         |
| **Parallel (吞吐量优先)** | 新生+老年代 | 多线程、高吞吐         | 后台计算型           |
| **CMS (并发低停顿)**      | 老年代      | 并发回收、低停顿       | 响应时间敏感         |
| **G1 (现代通用)**         | 混合分区    | 预测停顿时间、均衡性能 | 大内存服务端         |
| **ZGC / Shenandoah**      | 全堆并发    | 超低停顿（<10ms）      | 超大堆、延迟敏感应用 |

## GC 调优的步骤

### 1. 明确目标

通常优化方向有三类：

- **低延迟**：GC 停顿时间短（如交易系统）；
- **高吞吐**：GC 总时间占比低（如批处理系统）；
- **内存高效**：尽可能利用堆空间（如嵌入式应用）。

### 2. 监控和分析 GC 行为

#### 常用工具

- **命令行参数**

  ```bash
  -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log
  ```

- **在线分析工具**

  - `jstat`：查看 GC 统计信息。
  - `jvisualvm`、`JConsole`：图形化监控。
  - `GCViewer`、`GCeasy`：分析 GC 日志。

#### 核心指标

- **GC 次数与频率**
- **GC 停顿时间**
- **内存分配与回收速率**
- **老年代利用率**

## 常见调优策略

### 1. 堆大小调优

根据应用峰值负载动态调整：

```bash
-Xms4g -Xmx4g   # 固定堆大小，避免动态扩容开销
```

> 一般保持 `-Xms` = `-Xmx`。

### 2. 新生代比例调优

```bash
-XX:NewRatio=3    # 新生代 : 老年代 = 1 : 3
-XX:SurvivorRatio=8  # Eden : Survivor = 8 : 1 : 1
```

目标：让对象尽量在新生代被清除，减少晋升。

### 3. 晋升阈值调整

```bash
-XX:MaxTenuringThreshold=15
```

对象在 Survivor 区经过多少次 GC 后晋升老年代。
适当调高可以减少老年代压力。

### 4. GC 收集器选择

示例：

```bash
# 高吞吐应用
-XX:+UseParallelGC

# 响应速度优先
-XX:+UseG1GC

# 极低延迟（JDK 11+）
-XX:+UseZGC
```

### 5. Full GC 优化

- 减少显式调用 `System.gc()`；
- 调整元空间（Metaspace）大小；
- 排查大对象（直接晋升老年代）；
- 监控老年代利用率。

## G1 的专项调优示例

```bash
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200   # 目标最大停顿时间
-XX:InitiatingHeapOccupancyPercent=45   # 老年代触发混合GC的阈值
-XX:G1HeapRegionSize=16m   # 区块大小
```

调优逻辑：

1. 降低 `MaxGCPauseMillis` → 控制停顿；
2. 提高 `InitiatingHeapOccupancyPercent` → 延迟老年代回收；
3. 调整堆大小 → 稳定 GC 周期。

## 实战调优思路总结

| 现象            | 可能原因       | 调优思路                    |
| --------------- | -------------- | --------------------------- |
| GC 频繁，停顿短 | 新生代太小     | 增大新生代                  |
| Full GC 频繁    | 老年代空间不足 | 调大堆、降低晋升率          |
| 停顿时间过长    | GC 类型不合适  | 切换 G1/ZGC                 |
| 内存泄漏        | 对象未释放     | 使用 MAT/VisualVM 分析      |
| 元空间溢出      | 类加载过多     | 增大 `-XX:MaxMetaspaceSize` |

## 总结

- ✅ 先**分析 GC 日志**，再谈调优；
- ✅ **不要盲目改参数**，优先理解问题所在；
- ✅ G1/ZGC 通常足够应对 95% 的场景；
- ✅ 小内存系统优先 ParallelGC，大内存系统优先 G1/ZGC；
- ✅ 调优是一个 **数据驱动的过程**，持续观察与回归测试是关键。
