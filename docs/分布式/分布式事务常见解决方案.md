# 分布式事务常见解决方案

分布式事务是指跨多个服务或数据库系统的事务，需要保证 **数据一致性**。由于 CAP 理论的限制，在实际生产中往往需要在一致性、可用性、性能之间做权衡。常见解决方案可以分为以下几类：

## 一、两阶段提交（2PC, Two-Phase Commit）

### 思路

由协调者（Coordinator）控制事务的开始、提交、回滚：

1. **准备阶段**：所有参与者执行事务并锁定资源，返回“是否可以提交”。
2. **提交阶段**：如果所有参与者都同意提交，则协调者发送“提交”；否则发送“回滚”。

### 优点

- 思路简单，强一致性。

### 缺点

- 性能差，参与者长时间锁资源。
- 协调者单点故障风险大。
- 不适合高并发、大规模场景。

## 二、三阶段提交（3PC, Three-Phase Commit）

在 2PC 基础上多增加一个“预提交”阶段，减少阻塞。

- **CanCommit** → **PreCommit** → **DoCommit**。

### 优点

- 降低阻塞风险。

### 缺点

- 仍然复杂，使用场景有限，在工业界较少直接使用。

## 三、本地消息表（消息事务）

### 思路

1. 业务服务在本地事务中 **写业务数据 + 写一条消息记录**（保证原子性）。
2. 消息服务扫描消息表，投递到 MQ。
3. 下游服务消费消息并执行操作。
4. 确认后删除消息。

### 优点

- 避免强耦合，最终一致性。
- 依赖本地数据库事务，可靠性较高。

### 缺点

- 耦合到数据库，扩展性差。
- 需要定期补偿任务（扫描、重试）。

## 四、消息队列的事务消息（如 RocketMQ、Kafka）

### 思路

- 发送消息时先发送 **半消息**（不可见）。
- 本地事务执行完成后再确认消息提交。
- MQ 会回查事务状态，保证消息可靠投递。

### 优点

- 去除了本地消息表的依赖，直接由 MQ 保证一致性。
- 支持最终一致性。

### 缺点

- 依赖特定 MQ 实现，增加系统复杂度。
- 存在补偿机制，开发需处理幂等。

## 五、TCC（Try-Confirm-Cancel）

### 思路

- 业务显式拆分为三个阶段：

  - **Try**：预留资源。
  - **Confirm**：确认操作（正式提交）。
  - **Cancel**：释放资源（回滚）。

### 优点

- 灵活，性能好，不需要长事务锁。
- 适合金融支付、库存扣减等场景。

### 缺点

- 开发成本高，需要为每个业务编写 Try/Confirm/Cancel 接口。
- 业务侵入性大。

## 六、Saga 事务（长事务补偿机制）

### 思路

- 将业务流程拆分为一系列 **本地事务**。
- 如果中间某个步骤失败，按定义的 **补偿动作（Compensating Action）** 回滚之前的操作。

### 优点

- 解耦，适合长事务（如机票+酒店预订）。
- 最终一致性。

### 缺点

- 补偿逻辑复杂，幂等性、空回滚、悬挂事务需处理。
- 不保证强一致性。

## 七、柔性事务 + 补偿机制

综合多种方案：

- **幂等性**：保证重复执行不会产生副作用。
- **重试机制**：失败后可自动补偿。
- **定期对账**：保证一致性。

✅ **总结**：

- 需要**强一致性**（如银行核心转账） → 2PC / TCC。
- 可以接受**最终一致性**（如订单、库存、积分） → 本地消息表、事务消息、Saga。
- 复杂业务流程 → Saga 或 TCC。
