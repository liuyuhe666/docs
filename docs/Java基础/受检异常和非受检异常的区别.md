# 受检异常和非受检异常的区别

核心区别一句话概括：编译器是否强制要求你处理它。

## 对比表格

| 特征     | 受检异常 (Checked Exception)                                                     | 非受检异常 (Unchecked Exception)                                                                                                  |
| :------- | :------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------- |
| 强制处理 | 是。编译器会检查代码是否捕获或声明抛出了该异常。                                 | 否。编译器不强制要求处理，可以自由选择捕获或忽略。                                                                                |
| 继承自   | `java.lang.Exception` （但不包括 `RuntimeException` 及其子类）                   | `java.lang.RuntimeException` 或 `java.lang.Error`                                                                                 |
| 发生时机 | 通常发生在程序编译期可预测的、外部因素导致的错误。                               | 通常发生在程序运行期，代表编程逻辑错误或系统级问题。                                                                              |
| 代表性质 | 代表了一个合理的、可预期的问题，程序应该能从这种异常中恢复。                     | 代表了程序员的错误（如逻辑错误、使用不当）或不可恢复的 JVM 错误。                                                                 |
| 处理责任 | 调用者必须处理。这是 API 设计者与调用者之间的契约。                              | 调用者可以选择处理，但通常不处理。修正代码逻辑是更好的方式。                                                                      |
| 常见例子 | `IOException`, `SQLException`, `ClassNotFoundException`, `FileNotFoundException` | `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException`, `IllegalArgumentException`, `ClassCastException` |

详细解释

1. 受检异常 (Checked Exception)

受检异常是 `Exception` 类本身及其子类（不包括 `RuntimeException` 的子类）。

- 设计初衷：用于那些可预期的、但不在程序直接控制范围内的问题。例如，文件不存在、网络连接中断、数据库访问失败等。这些情况不是代码逻辑错误，而是外部环境的问题，一个健壮的程序应该能够捕获这些异常并尝试恢复（例如，提示用户“文件不存在，请重新输入路径”）。
- 编译器行为：如果一个方法内部可能抛出受检异常，编译器会强制要求开发者做两件事之一：
  1.  捕获 (Catch)：使用 `try-catch` 块在方法内部处理异常。
  2.  声明抛出 (Declare)：在方法签名中使用 `throws` 关键字声明该方法可能抛出的异常类型，将处理责任交给该方法的调用者。

示例：处理受检异常 (IOException)

```java
// 方式一：捕获 (try-catch)
public void readFile() {
    try {
        FileReader file = new FileReader("somefile.txt");
        // ... 读取文件
    } catch (FileNotFoundException e) { // FileNotFoundException 是 IOException 的子类
        System.out.println("文件未找到，请检查路径！");
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

// 方式二：声明抛出 (throws)
public void readFile() throws IOException { // 告知调用者，我可能会抛IOException
    FileReader file = new FileReader("somefile.txt");
    // ... 读取文件
}
// 此时，调用 readFile() 的方法就必须处理 IOException 或继续向上抛出。
```

2. 非受检异常 (Unchecked Exception)

非受检异常包括`RuntimeException` 及其子类和`Error`及其子类。

- RuntimeException (运行时异常):

  - 代表原因：通常是程序员的逻辑错误或 API 使用不当。例如，空指针、数组越界、类型转换错误、非法参数等。
  - 处理哲学：这些 bug 应该在开发阶段通过代码审查和测试来避免，而不是在运行时通过捕获来处理。捕获它们通常是为了在顶层记录日志或给用户一个友好的错误提示，然后优雅地终止程序，而不是尝试恢复。修正代码逻辑才是根本解决办法。

- Error:
  - 代表原因：代表了严重的、应用程序通常无法处理或恢复的 JVM 层级错误。例如，`OutOfMemoryError`（内存耗尽）、`StackOverflowError`（栈溢出）、`VirtualMachineError`（虚拟机错误）。
  - 处理建议：应用程序不应该尝试去捕获`Error`及其子类，因为即使捕获了，通常也无法从中恢复。应该让程序终止，然后检查并修复根本原因（如内存泄漏、无限递归等）。

示例：非受检异常（通常是编程错误）

```java
// 1. NullPointerException
String str = null;
int length = str.length(); // 运行时抛出 NullPointerException

// 2. ArrayIndexOutOfBoundsException
int[] arr = new int[5];
int value = arr[10]; // 运行时抛出 ArrayIndexOutOfBoundsException

// 3. 捕获 RuntimeException（通常不推荐针对性地捕获，除非你有明确的恢复策略）
public void processUserInput(String input) {
    try {
        int number = Integer.parseInt(input); // 如果input不是数字，抛出NumberFormatException
    } catch (NumberFormatException e) {
        System.out.println("输入格式错误，请输入数字！");
    }
}
```

## 如何选择？

这是一个设计哲学问题，但有一些通用准则：

- 使用受检异常：当调用者有责任且有可能性从异常中恢复时。例如，文件没找到，可以提示用户换一个文件。
- 使用非受检异常 (RuntimeException):
  - 当错误是编程错误或逻辑错误时（如前置条件检查失败，传入了非法参数）。
  - 当错误无法恢复，或者强制每一个调用者都处理异常会使得代码非常繁琐且收益甚微时。
  - 现代框架（如 Spring）更倾向于使用非受检异常，以减少代码的侵入性。

## 总结

|          | 受检异常                             | 非受检异常                                  |
| :------- | :----------------------------------- | :------------------------------------------ |
| 关键问句 | “调用者应该并且能够处理这个异常吗？” | “这是一个程序错误(Bug)或不可恢复的错误吗？” |
| 处理方式 | 必须被捕获或声明抛出                 | 可以被捕获，但通常不强制                    |
