# select、poll、epoll 的区别

`select`、`poll` 和 `epoll` 都是 I/O 多路复用的技术，用于让一个进程或线程能够同时监听多个文件描述符（如网络套接字），从而高效地处理高并发连接。

简单来说，I/O 多路复用允许一个“服务员”（单线程/进程）同时照看多个“顾客”（网络连接）。当某个顾客有需求（数据可读或可写）时，服务员才会去处理他，而不是一直守在一个顾客旁边。`select`、`poll`、`epoll` 就是实现这个“照看”功能的三种不同方法。

## select

`select` 是最早出现的方法（在 BSD 4.2 中，1983 年左右）。

工作机制：

1.  程序将需要监视的文件描述符集合（分为读、写、异常三类）通过 `FD_SET` 宏添加到 `fd_set` 结构中。
2.  调用 `select` 函数，内核会轮询检查所有被加入集合的 fd。
3.  当有 fd 就绪或超时，`select` 返回。
4.  程序必须遍历整个 fd 集合，使用 `FD_ISSET` 宏来找出哪些 fd 真正就绪了。

缺点：

- 监听的 fd 数量有上限：由 `FD_SETSIZE`（通常是 1024）定义，编译时很难修改。
- 性能随 fd 数量线性下降：每次调用 `select`，都需要将整个 fd_set 从用户态拷贝到内核态。内核和应用程序在返回后都需要遍历所有 fd 来找出就绪的，当 fd 很多但活跃度不高时，效率很低。
- fd_set 被内核修改：每次调用后，内核会修改传入的 `fd_set` 结构，告诉程序哪些 fd 就绪了。因此，下一次调用前，程序必须重置（重新添加）这些集合。

## poll

`poll` 在 System V 中引入，旨在解决 `select` 的一些限制。

工作机制：

1.  程序提供一个 `pollfd` 结构数组，每个元素包含一个 fd 和其需要监视的事件（读、写、错误等）。
2.  调用 `poll` 函数。
3.  内核轮询检查所有 `pollfd` 中的 fd。
4.  返回时，内核会修改每个 `pollfd` 中的 `revents` 字段，表示实际发生的事件。
5.  程序遍历整个 `pollfd` 数组，检查 `revents` 字段来找出就绪的 fd。

改进：

- 无最大数量限制：`pollfd` 数组的大小由程序决定，理论上只受系统资源限制。
- 更细粒度的事件控制：监视的事件和返回的事件是分开的（`events` 和 `revents`），无需像 `select` 那样每次调用前重置 fd 集合。

遗留的缺点：

- 性能问题依旧：和 `select` 一样，内核和应用程序都需要遍历整个监听列表来找出就绪的 fd。随着监听数量的增加，性能会下降。同样，每次调用都需要将整个 `pollfd` 数组从用户态拷贝到内核态。

## epoll

`epoll` 是 Linux 2.5.44 中引入的，是 Linux 特有的高性能 I/O 多路复用机制。它完美地解决了 `select` 和 `poll` 的性能瓶颈。

工作机制：
`epoll` 使用一组三个系统调用：`epoll_create`, `epoll_ctl`, `epoll_wait`。

1.  `epoll_create`: 创建一个 `epoll` 实例，返回一个文件描述符。
2.  `epoll_ctl`: （唯一需要拷贝的地方）用于向 `epoll` 实例（第一步创建的）添加、修改或删除要监听的 fd 及其事件。这个过程是一次性的，不是在每次循环调用中都会发生。
3.  `epoll_wait`: （高效的核心） 等待事件发生。调用时，内核会返回一个就绪事件的数组。应用程序无需遍历所有监听的 fd，只需直接处理这个就绪数组即可。

优点：

- 无 fd 数量限制：基于红黑树管理 fd，仅受系统最大文件描述符数量限制。
- 极高的性能：
  - 避免了重复拷贝：通过 `epoll_ctl` 预先注册 fd，避免了每次调用时都将整个 fd 集合从用户态拷贝到内核态。
  - 避免了线性遍历：内核使用回调机制。当某个 fd 就绪时，内核会将其放入一个就绪链表。`epoll_wait` 只需从就绪链表中取出事件返回给应用程序，时间复杂度是 O(1)。而应用程序也只需处理返回的就绪事件，无需扫描所有监听的 fd。
- 支持边缘触发（ET）和水平触发（LT）模式：
  - 水平触发（LT，默认）：只要 fd 处于就绪状态（例如读缓冲区不为空），每次调用 `epoll_wait` 都会通知你。类似于 `select`/`poll` 的行为。
  - 边缘触发（ET）：只有当 fd 状态发生变化时（例如读缓冲区从无数据变为有数据），才会通知一次。如果第一次没有读完数据，除非有新的数据到来再次触发，否则 `epoll_wait` 不会再次通知。ET 模式要求应用程序必须使用非阻塞 I/O 并一次性读完或写完所有数据，效率更高，但编程更复杂。

## 总结

| 特性        | select                                   | poll                                        | epoll                                   |
| :---------- | :--------------------------------------- | :------------------------------------------ | :-------------------------------------- |
| 跨平台      | 几乎所有平台                             | 大多数 UNIX 系统                            | 仅 Linux                                |
| 最大连接数  | 有限制 (FD_SETSIZE, 通常 1024)           | 无限制（基于数组大小）                      | 无限制（基于系统资源）                  |
| 工作效率    | 线性遍历 O(n)                            | 线性遍历 O(n)                               | 回调机制 O(1)                           |
| fd 拷贝方式 | 每次调用 `select`，都需要完整拷贝 fd_set | 每次调用 `poll`，都需要完整拷贝 pollfd 数组 | 通过 `epoll_ctl` 注册一次，后续无需拷贝 |
| 编程复杂度  | 中等                                     | 中等                                        | 较低（但 ET 模式较复杂）                |
| 触发模式    | 仅水平触发（LT）                         | 仅水平触发（LT）                            | 支持水平触发（LT）和边缘触发（ET）      |
| 内核实现    | 轮询                                     | 轮询                                        | 回调（红黑树+就绪链表）                 |

一个生动的比喻：

- select/poll：像一个服务员，每来一桌客人就跑去问一遍：“您的菜好了吗？您的饮料要加吗？...”（需要主动轮询每一桌）。
- epoll：像一个配备了呼叫铃的服务员。客人需要服务时按一下铃（回调），铃的编号会显示在服务台的屏幕上（就绪链表）。服务员只需要看屏幕，然后去处理那些按了铃的桌子即可。

## 使用建议

1.  需要跨平台：使用 `select` 或 `poll`。`select` 更普遍，但 `poll` 更现代且无连接数限制。
2.  高性能 Linux 服务器：无条件选择 `epoll`。它是处理成千上万个并发连接的首选方案，例如 Nginx、Redis、Memcached 等知名软件都使用 `epoll`。
3.  连接数少且活跃度高：在这种情况下，`select` 或 `poll` 的性能可能并不比 `epoll` 差，甚至因为系统调用更简单而略有优势。但对于绝大多数网络应用（连接数多，活跃度低），`epoll` 的优势是压倒性的。
