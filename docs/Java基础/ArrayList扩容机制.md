# ArrayList 扩容机制

## 核心步骤

ArrayList 的底层是一个动态数组（`Object[] elementData`），当添加元素时，如果发现当前数组已满，它就会自动进行扩容，以便能容纳新的元素。

其扩容过程的核心步骤如下：

1.  检查容量：当你调用 `add(E e)` 方法时，它会先检查当前数组的剩余空间是否足够容纳一个新元素。

    ```java
    public boolean add(E e) {
        ensureCapacityInternal(size + 1); // 确保内部容量至少为 size+1
        elementData[size++] = e;
        return true;
    }
    ```

2.  计算最小所需容量：`ensureCapacityInternal()` 方法会计算出最少需要多大的容量（例如，当前元素数量 + 1）。

3.  判断是否需要扩容：`ensureExplicitCapacity()` 方法会判断这个“最小所需容量”是否大于当前数组的长度。如果是，则调用 `grow()` 方法开始扩容。

    ```java
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
        if (minCapacity - elementData.length > 0)
            grow(minCapacity); // 触发扩容
    }
    ```

4.  执行扩容（核心方法 `grow()`）：

    ```java
    private void grow(int minCapacity) {
        // oldCapacity 是旧数组的容量
        int oldCapacity = elementData.length;

        // newCapacity 是新数组的容量，计算方式为：oldCapacity + (oldCapacity >> 1)
        // 即新容量 = 旧容量 * 1.5
        int newCapacity = oldCapacity + (oldCapacity >> 1);

        // 特殊情况处理：如果计算出的新容量仍然小于最小所需容量
        // （例如，从初始容量0扩容时，0*1.5还是0，这时就会使用minCapacity）
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;

        // 另一个边界处理：如果新容量超过了数组的最大大小限制
        // （有些VM可能无法分配特别大的数组），则使用 `hugeCapacity` 方法处理
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);

        // 最关键的一步：将旧数组中的数据复制到一个新的、容量为 newCapacity 的数组中
        // 这是扩容操作中开销最大的部分
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    ```

关键点总结：

- 默认初始容量：如果不指定，创建 `new ArrayList()` 时，底层数组初始容量为 10。
- 扩容公式：新容量 = 旧容量 + 旧容量 / 2（即大约 1.5 倍）。通过位运算 `oldCapacity >> 1` 实现除以 2，效率更高。
- 扩容操作：底层调用 `Arrays.copyOf()`，这是一个耗时操作，因为它需要将原数组中的元素逐个复制到新数组中。

## 为什么是 1.5 倍？而不是 2 倍、3 倍或固定值？

选择 1.5 倍作为一个扩容因子（Growth Factor），是工程上的一种权衡，旨在平衡性能和内存空间的消耗。主要原因如下：

1. 避免空间浪费（与 2 倍扩容对比）

- 如果采用 2 倍扩容（例如 10, 20, 40, 80...），扩容速度非常快，能最大限度地减少复制操作的次数。
- 缺点：空间浪费可能比较严重。比如，一个 ArrayList 最终存储了 100 万个元素，在最后一次扩容时，数组容量会从 50 万直接跳到 100 万。虽然最终用了 100 万，但实际分配了 100 万的空间，多余的 50 万空间被闲置了，内存利用率不高。
- 而 1.5 倍扩容（例如 10, 15, 22, 33, 49...）的步进更平滑，每次扩容分配的“额外空间”相对更少，在多数情况下能提供更好的内存使用效率。

2. 避免频繁扩容（与更小的扩容因子或固定值对比）

- 如果每次只增加一个固定的容量（例如每次只增加 10），那么当元素数量很大时，就需要非常频繁地进行扩容。而每次扩容都涉及昂贵的数组复制操作，这会严重拖慢性能。
- 1.5 倍是一个指数级增长（虽然指数小于 2），它能够保证随着元素数量的增加，扩容发生的频率会显著降低。例如，从 1000 个元素开始，需要再添加 500 个元素才会触发下一次扩容，这比固定值扩容要好得多。

3. 数学上的优势 - 与斐波那契数列有关

- 在计算机科学中，1.5（实际上是约等于黄金比例 0.618 的倒数）是一个常见的增长因子。有一个与之相关的概念叫“黄金比例扩容”。
- 理论上，使用黄金比例（约 1.618）作为扩容因子，可以让之前每次扩容时被释放的旧内存块有更大的机会被复用，从而减少内存碎片化的可能。虽然 Java 的 ArrayList 没有严格采用 1.618，但 1.5 是一个在效率和实现简单性上很好的近似值。
- 1.5 可以通过高效的位运算 `oldCapacity + (oldCapacity >> 1)` 来实现，计算速度快。

## 总结

| 扩容策略              | 优点                             | 缺点                       | 使用者                                        |
| :-------------------- | :------------------------------- | :------------------------- | :-------------------------------------------- |
| Java ArrayList (1.5x) | 良好的平衡，兼顾性能和空间利用率 | 并非理论最优               | Java                                          |
| 2 倍扩容              | 性能最好，扩容次数最少           | 空间浪费最大               | 许多其他语言/库，如 Go 的切片、Python 的 list |
| 固定值扩容            | 实现简单                         | 性能极差，大容量时频繁扩容 | 不常用于主流动态数组实现                      |

结论：
选择 1.5 倍是 Java 设计者的一种工程上的折中方案。它在减少扩容次数（时间成本）和减少内存浪费（空间成本）之间取得了很好的平衡。它是一个经过实践检验的、在大多数场景下都能提供良好性能的经验值。

> 注意：这个值并非绝对。在 Java 的早期版本中，`Vector`类的扩容策略是“`旧容量 * 2`”（2 倍扩容）。ArrayList 作为 Vector 的现代替代品，选择了更节省空间的 1.5 倍策略。不同的编程语言和库可能会根据其设计目标选择不同的扩容因子。
