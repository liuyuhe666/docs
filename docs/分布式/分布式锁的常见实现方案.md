# 分布式锁的常见实现方案

分布式锁的目标是保证在分布式系统中多个节点对共享资源的互斥访问。常见的实现方案主要有以下几类：

## 1. 基于数据库实现

**原理**：利用数据库的唯一约束/事务机制来保证锁。
**常见方式**：

- **基于唯一索引插入**：
  尝试 `INSERT INTO lock_table(resource, expire_time) VALUES(...)`，如果失败说明已有锁。
- **基于行锁**：
  `SELECT ... FOR UPDATE`，依赖数据库行级锁。

✅ 优点：实现简单，易用，无需额外组件。

❌ 缺点：性能有限，存在单点瓶颈，不适合高并发。

## 2. 基于缓存（Redis 等）实现

**原理**：利用 Redis 提供的 `SETNX` + `EXPIRE` 原子操作来保证互斥。
**常见方式**：

- **SETNX + EXPIRE**（老方案，可能出现 SETNX 成功但未设置过期时间的风险）
- **SET key value NX PX ttl**（推荐，单条命令完成获取锁 + 设置过期时间）
- **RedLock 算法**（Redis 官方提出，基于多个 Redis 节点，避免单点问题）

✅ 优点：性能高，简单易用，社区成熟。

❌ 缺点：过期时间不好设定（可能误释放锁）；RedLock 存在争议。

## 3. 基于 Zookeeper 实现

**原理**：利用 Zookeeper 的 **临时有序节点**和 **watch 机制**。
**常见方式**：

1. 所有客户端在某个路径下创建临时有序节点 `/lock/lock-0001`
2. 节点序号最小的客户端获得锁
3. 其他客户端监听比自己小的前一个节点，前一个节点删除后再竞争

✅ 优点：锁安全可靠，天然支持阻塞与顺序、公平性；不会死锁（客户端宕机临时节点自动删除）。

❌ 缺点：性能一般，ZK 本身运维复杂。

## 4. 基于 Etcd / Consul 实现

**原理**：利用 Etcd/Consul 提供的 **租约（lease）+KV** 或 **会话（session）** 机制。

- 创建带租约的 key，租约过期自动删除，防止死锁。
- Watch 机制实现锁竞争和通知。

✅ 优点：一致性高（Raft 协议），适合云原生环境。

❌ 缺点：吞吐量一般，依赖额外组件。

## 5. 基于消息队列实现（较少用）

**原理**：将对共享资源的访问请求序列化到 MQ 中，消费者串行消费即可实现锁。

✅ 优点：简单粗暴，适合特定场景。

❌ 缺点：不是严格意义上的锁，延迟较高。

## 总结

- **数据库锁**：简单，适合低并发小型系统。
- **Redis 锁**：高性能，使用最广泛，但需处理超时和可靠性。
- **Zookeeper 锁**：强一致，适合对可靠性要求高的场景。
- **Etcd/Consul 锁**：云原生环境常用，适合和 Kubernetes 等集成。

👉 如果你是在实际项目中选型：

- **互联网高并发场景**：优先 Redis（必要时 RedLock 或加业务补偿）。
- **强一致、高可靠场景**：优先 Zookeeper / Etcd。
- **中小项目或临时方案**：数据库锁即可。
