# 为什么用 B+ 树而不是 B 树

B 树和 B+ 树的核心区别在于**数据的存储位置**和**叶子节点的连接**。正是这些区别让 B+ 树在数据库索引中完胜 B 树。

| 特性             | B 树                                                                   | B+ 树                                                          | **B+ 树的优势**                                                                                                                                                                                                                                                                                                                                                                                                                               |
| :--------------- | :--------------------------------------------------------------------- | :------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **数据存储**     | **每个节点**都存储键 **和** 对应的数据（或指针）。                     | 只有**叶子节点**存储数据（或指针），**内部节点只存键和指针**。 | **1. 更低的树高（查询更稳定）：** 由于内部节点不存数据，同样大小的节点可以存储**更多的键**，从而大大增加了分支因子，降低了树的高度。对于大规模数据，B+ 树通常比 B 树更“矮胖”，这意味着**任何查询都需要相同次数的磁盘 I/O**（都是从根走到叶），性能稳定。<br>**2. 更高的缓存效率：** 数据库会将索引节点以“页”为单位加载到内存。因为 B+ 树的内部节点没有数据，**一次磁盘 I/O 可以加载更多的键**到内存中，缓存命中率更高，进一步减少了磁盘访问。 |
| **叶子节点连接** | 叶子节点之间**没有**额外的指针连接。                                   | 所有叶子节点通过指针**串联成一个有序的双向链表**。             | **3. 扫库和范围查询性能极佳：** 这是**最致命**的优势。进行 `SELECT * FROM table` 全表扫描或 `WHERE key BETWEEN 10 AND 100` 这样的范围查询时，B+ 树只需要在叶子节点的链表上做一次线性遍历即可。而 **B 树需要进行繁琐的、多次的中序遍历**，涉及大量的随机 I/O 和回溯，性能差得多。数据库中最常见的操作就是范围查询。                                                                                                                            |
| **查询性能**     | 最好情况（数据在根节点）很快，最坏情况（数据在叶子节点）和 B+ 树一样。 | **任何查询**都必须从根走到叶，**性能非常稳定**。               | **4. 稳定的性能：** 对于 B 树，有时可能在内部节点就找到数据并返回，但这带来了不确定性。而 B+ 树每次查询的路径长度都是固定的（树的高度），这使得数据库引擎更容易对查询性能进行预测和优化。                                                                                                                                                                                                                                                     |
| **空间利用率**   | 每个节点都存储数据，可能导致节点能容纳的键数量减少。                   | 内部节点不存储数据，空间利用率更高。                           | 间接导致了第 1 点（树高更低）的优势。                                                                                                                                                                                                                                                                                                                                                                                                         |

总结

数据库选择 B+ 树而不是 B 树，主要基于以下两个核心原因：

1.  **极高的范围查询效率**：叶子节点的双向链表结构使得顺序扫描和范围查询的效率远超 B 树，而这是数据库 workload 中最常见的操作之一。
2.  **更稳定的查询性能和更低的磁盘 I/O**：由于树高更低、内部节点能缓存更多键，使得每次查询的磁盘 I/O 次数更少、更稳定。

简而言之，**B+ 树的结构是为数据库的查询模式（尤其是范围查询）和磁盘的存取特性（顺序读写快于随机读写）量身定做的**。虽然 B 树在某些点查询上可能稍快（比如数据恰好在根节点），但综合考虑**稳定性、范围查询和全表扫描**这些数据库最看重的指标，B+ 树是毫无疑问的更优选择。
