### 不同 Java 版本中，HashMap 的核心区别 (JDK 1.7 vs. JDK 1.8)

JDK 1.8 对 HashMap 进行了大量优化，主要集中在数据结构、哈希冲突解决、扩容机制和性能上。

| 特性          | JDK 1.7                      | JDK 1.8                               | 优势和影响                                                                                              |
| :------------ | :--------------------------- | :------------------------------------ | :------------------------------------------------------------------------------------------------------ |
| 底层数据结构  | 数组 + 链表                  | 数组 + 链表 + 红黑树                  | 1.8 中当链表过长时，会转为红黑树，极大提升了查询效率（O(n) -> O(log n)）。                              |
| 哈希冲突解决  | 头插法（新元素插入链表头部） | 尾插法（新元素插入链表尾部）          | 头插法在多线程扩容时会产生循环链表问题，尾插法解决了这个致命的并发问题（但 HashMap 本身仍非线程安全）。 |
| 扩容机制      | 先扩容，再插入新元素         | 先插入新元素，再扩容                  | 1.8 的扩容优化了计算元素新位置的方式，效率更高。                                                        |
| hash 算法优化 | 哈希计算较复杂，扰动次数多   | 哈希计算更简洁，但扰动效果更好        | 1.8 将 hashCode 的高 16 位与低 16 位进行异或，减少了哈希冲突，更均匀。                                  |
| 插入逻辑      | `put()` 操作分散在多个方法中 | `put()` 逻辑整合进一个方法 `putVal()` | 代码可读性和可维护性更强。                                                                              |

#### 详细解释：

1.  数据结构：红黑树的引入 (最重要的优化)

    - JDK 1.7: 纯粹使用数组和链表。当发生哈希冲突时，会将冲突的键值对形成一个链表。在极端情况下（如所有 key 的 hashCode 都相同），HashMap 会退化为一个长链表，查询效率从 O(1)暴跌至 O(n)。
    - JDK 1.8: 引入了红黑树。当链表的长度超过阈值（默认为 8）并且数组的长度达到一定阈值（默认为 64）时，链表会转换为红黑树。红黑树是一种自平衡的二叉查找树，能将查询、插入、删除的最坏时间复杂度都控制在 O(log n)，有效防止了哈希碰撞攻击，提升了性能。

2.  插入方式：头插法 vs. 尾插法

    - JDK 1.7 - 头插法: 基于“最近插入的元素更可能被访问”的假设。但在多线程环境下扩容时，`resize()` 方法中的链表转移操作会导致链表节点指向混乱，形成循环链表。后续一旦有查询操作触及这个循环链表，就会导致 CPU 飙升至 100%，出现死循环。
    - JDK 1.8 - 尾插法: 在扩容时，会保持链表中原有元素的顺序。这样即使多个线程同时触发了扩容，也不会产生循环链表的问题。注意：这并没有让 HashMap 变得线程安全！它只是修复了一个非常严重的并发 BUG，但依然存在数据覆盖等其它并发问题。

3.  扩容机制优化
    - JDK 1.7: 在插入元素前，先判断是否需要扩容。扩容后，所有元素需要重新计算在新数组中的位置（`rehash`）。
    - JDK 1.8: 在插入元素后，再判断是否需要扩容。并且，由于数组长度永远是 2 的幂次方，1.8 优化了元素新位置的计算：元素的新位置要么是原位置，要么是原位置 + 旧容量。通过判断新增的 hash 位是 0 还是 1 即可，无需再重新计算 hash 值，提升了扩容速度。

### HashMap 线程安全吗？

不，HashMap 在任何版本都是线程不安全的。

虽然 JDK 1.8 通过改用尾插法修复了令人闻风丧胆的死循环问题，但这并不代表它在多线程环境下就是安全的。

在多线程并发操作下，HashMap 仍然会导致以下问题：

1.  数据覆盖 (最主要的问题)

    - 当两个线程同时执行 `put()` 操作，并且计算出的桶位置（bucket index）相同，它们可能会尝试插入同一个位置。
    - 假设线程 A 和线程 B 都发现位置 i 是空的，于是它们都会尝试将数据插入 i。最终，后一个线程 put 的值会覆盖前一个线程 put 的值，导致前一个线程的数据丢失。

2.  扩容导致的数据丢失

    - 在并发扩容时，多个线程同时操作同一个链表或树，可能会导致节点引用混乱，造成部分数据在扩容后 mysteriously “消失”。

3.  非原子操作导致的 size 不准确
    - HashMap 的 `size` 是通过一个变量单独维护的。多线程同时进行 put 操作时，这个变量的更新可能不会同步，导致最终 `size()` 返回的结果与实际的键值对数量不符。

结论：绝对不要在多线程环境下使用 HashMap。如果你需要线程安全的 Map，请使用：

- `ConcurrentHashMap` (首选)：采用分段锁（JDK 1.7）或 CAS + synchronized（JDK 1.8），性能远高于 `Hashtable`。
- `Collections.synchronizedMap(new HashMap<>())`：它会返回一个将所有 Map 方法用 `synchronized` 块包装的代理对象，性能较差。
- `Hashtable` (已过时)：一个全表锁的古老实现，并发性能极差，不推荐使用。
